use crypto::aessafe;
use crypto::symmetriccipher::{BlockDecryptor, BlockEncryptor};

use error::MatasanoError;

// Challenge 9
pub fn pkcs_pad_string(string: &str, block_size: usize) -> String {
    let padding_len = (string.len() / block_size + 1) * block_size % string.len();

    let mut padded_string = String::with_capacity(string.len() + padding_len);

    padded_string.push_str(string);

    for _ in 0..padding_len {
        padded_string.push('\x04');
    }

    padded_string
}

// Challenge 10
pub fn decrypt_aes_cbc_string(cipher_bytes: &[u8], key: &[u8], iv: &[u8]) -> Result<String, MatasanoError> {
    let decryptor = aessafe::AesSafe128Decryptor::new(key);

    let mut decoded_vec = Vec::with_capacity(cipher_bytes.len());
    let mut buffer = vec![0; decryptor.block_size()];
    let mut current_iv = iv;

    for cipher_block in cipher_bytes.chunks(decryptor.block_size()) {
        decryptor.decrypt_block(&cipher_block, &mut buffer[..]);

        for (decoded_byte, iv_byte) in buffer.iter().zip(current_iv.iter()) {
            decoded_vec.push(decoded_byte ^ iv_byte);
        }

        current_iv = &cipher_block;
    }

    Ok(String::from_utf8(decoded_vec)?)
}

pub fn encrypt_aes_cbc_string(plain_text: &str, key: &[u8], iv: &[u8]) -> Result<Vec<u8>, MatasanoError> {
    let encryptor = aessafe::AesSafe128Encryptor::new(key);

    let mut encoded_vec = Vec::with_capacity(plain_text.len());
    let mut buffer = vec![0; encryptor.block_size()];

    buffer.clone_from_slice(iv);

    for text_block in plain_text.as_bytes().chunks(encryptor.block_size()) {
        let curren = text_block.iter().zip(buffer.iter()).map(|(text_byte, iv_byte)|
            text_byte ^ iv_byte
        ).collect::<Vec<u8>>();

        encryptor.encrypt_block(&curren[..], &mut buffer[..]);

        encoded_vec.extend_from_slice(&buffer);
    }

    Ok(encoded_vec)
}
